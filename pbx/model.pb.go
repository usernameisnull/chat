// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

/*
Package pbx is a generated protocol buffer package.

It is generated from these files:
	model.proto

It has these top-level messages:
	Unused
	DefaultAcsMode
	AccessMode
	SetSub
	SetDesc
	GetOpts
	BrowseOpts
	GetQuery
	SetQuery
	ClientHi
	ClientAcc
	ClientLogin
	ClientSub
	ClientLeave
	ClientPub
	ClientGet
	ClientSet
	ClientDel
	ClientNote
	ClientMsg
	TopicDesc
	TopicSub
	ServerCtrl
	ServerData
	ServerPres
	ServerMeta
	ServerInfo
	ServerMsg
	ServerResp
	Session
	ClientReq
	TopicEvent
	AccountEvent
	SubscriptionEvent
	MessageEvent
*/
package pbx

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InfoNote int32

const (
	InfoNote_READ InfoNote = 0
	InfoNote_RECV InfoNote = 1
	InfoNote_KP   InfoNote = 2
)

var InfoNote_name = map[int32]string{
	0: "READ",
	1: "RECV",
	2: "KP",
}
var InfoNote_value = map[string]int32{
	"READ": 0,
	"RECV": 1,
	"KP":   2,
}

func (x InfoNote) String() string {
	return proto.EnumName(InfoNote_name, int32(x))
}
func (InfoNote) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Crud int32

const (
	Crud_CREATE Crud = 0
	Crud_UPDATE Crud = 1
	Crud_DELETE Crud = 2
)

var Crud_name = map[int32]string{
	0: "CREATE",
	1: "UPDATE",
	2: "DELETE",
}
var Crud_value = map[string]int32{
	"CREATE": 0,
	"UPDATE": 1,
	"DELETE": 2,
}

func (x Crud) String() string {
	return proto.EnumName(Crud_name, int32(x))
}
func (Crud) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// What to delete, either "msg" to delete messages (default) or "topic" to delete the topic or "sub"
// to delete a subscription to topic.
type ClientDel_What int32

const (
	ClientDel_MSG   ClientDel_What = 0
	ClientDel_TOPIC ClientDel_What = 1
	ClientDel_SUB   ClientDel_What = 2
)

var ClientDel_What_name = map[int32]string{
	0: "MSG",
	1: "TOPIC",
	2: "SUB",
}
var ClientDel_What_value = map[string]int32{
	"MSG":   0,
	"TOPIC": 1,
	"SUB":   2,
}

func (x ClientDel_What) String() string {
	return proto.EnumName(ClientDel_What_name, int32(x))
}
func (ClientDel_What) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{17, 0} }

type ServerPres_What int32

const (
	ServerPres_ON   ServerPres_What = 0
	ServerPres_OFF  ServerPres_What = 1
	ServerPres_UA   ServerPres_What = 3
	ServerPres_UPD  ServerPres_What = 4
	ServerPres_GONE ServerPres_What = 5
	ServerPres_ACS  ServerPres_What = 6
	ServerPres_TERM ServerPres_What = 7
	ServerPres_MSG  ServerPres_What = 8
	ServerPres_READ ServerPres_What = 9
	ServerPres_RECV ServerPres_What = 10
	ServerPres_DEL  ServerPres_What = 11
)

var ServerPres_What_name = map[int32]string{
	0:  "ON",
	1:  "OFF",
	3:  "UA",
	4:  "UPD",
	5:  "GONE",
	6:  "ACS",
	7:  "TERM",
	8:  "MSG",
	9:  "READ",
	10: "RECV",
	11: "DEL",
}
var ServerPres_What_value = map[string]int32{
	"ON":   0,
	"OFF":  1,
	"UA":   3,
	"UPD":  4,
	"GONE": 5,
	"ACS":  6,
	"TERM": 7,
	"MSG":  8,
	"READ": 9,
	"RECV": 10,
	"DEL":  11,
}

func (x ServerPres_What) String() string {
	return proto.EnumName(ServerPres_What_name, int32(x))
}
func (ServerPres_What) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{24, 0} }

// Plugin response codes
type ServerResp_RespCode int32

const (
	// Instruct Tinode server to continue with default processing of the client message.
	ServerResp_CONTINUE ServerResp_RespCode = 0
	// Drop the message as if the client did not send it
	ServerResp_DROP ServerResp_RespCode = 1
	// Respond to client with the provided srvmsg
	ServerResp_RESPOND ServerResp_RespCode = 2
	// Replace client's original message with the provided clmsg then continue with
	// processing.
	ServerResp_REPLACE ServerResp_RespCode = 3
)

var ServerResp_RespCode_name = map[int32]string{
	0: "CONTINUE",
	1: "DROP",
	2: "RESPOND",
	3: "REPLACE",
}
var ServerResp_RespCode_value = map[string]int32{
	"CONTINUE": 0,
	"DROP":     1,
	"RESPOND":  2,
	"REPLACE":  3,
}

func (x ServerResp_RespCode) String() string {
	return proto.EnumName(ServerResp_RespCode_name, int32(x))
}
func (ServerResp_RespCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{28, 0} }

type Session_AuthLevel int32

const (
	Session_NONE Session_AuthLevel = 0
	Session_ANON Session_AuthLevel = 10
	Session_AUTH Session_AuthLevel = 20
	Session_ROOT Session_AuthLevel = 30
)

var Session_AuthLevel_name = map[int32]string{
	0:  "NONE",
	10: "ANON",
	20: "AUTH",
	30: "ROOT",
}
var Session_AuthLevel_value = map[string]int32{
	"NONE": 0,
	"ANON": 10,
	"AUTH": 20,
	"ROOT": 30,
}

func (x Session_AuthLevel) String() string {
	return proto.EnumName(Session_AuthLevel_name, int32(x))
}
func (Session_AuthLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{29, 0} }

// Dummy placeholder message
type Unused struct {
}

func (m *Unused) Reset()                    { *m = Unused{} }
func (m *Unused) String() string            { return proto.CompactTextString(m) }
func (*Unused) ProtoMessage()               {}
func (*Unused) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Topic default access mode
type DefaultAcsMode struct {
	Auth string `protobuf:"bytes,1,opt,name=auth" json:"auth,omitempty"`
	Anon string `protobuf:"bytes,2,opt,name=anon" json:"anon,omitempty"`
}

func (m *DefaultAcsMode) Reset()                    { *m = DefaultAcsMode{} }
func (m *DefaultAcsMode) String() string            { return proto.CompactTextString(m) }
func (*DefaultAcsMode) ProtoMessage()               {}
func (*DefaultAcsMode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DefaultAcsMode) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func (m *DefaultAcsMode) GetAnon() string {
	if m != nil {
		return m.Anon
	}
	return ""
}

// Actual access mode
type AccessMode struct {
	// Access mode requested by the user
	Want string `protobuf:"bytes,1,opt,name=want" json:"want,omitempty"`
	// Access mode granted to the user by the admin
	Given string `protobuf:"bytes,2,opt,name=given" json:"given,omitempty"`
}

func (m *AccessMode) Reset()                    { *m = AccessMode{} }
func (m *AccessMode) String() string            { return proto.CompactTextString(m) }
func (*AccessMode) ProtoMessage()               {}
func (*AccessMode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AccessMode) GetWant() string {
	if m != nil {
		return m.Want
	}
	return ""
}

func (m *AccessMode) GetGiven() string {
	if m != nil {
		return m.Given
	}
	return ""
}

// SetSub: payload in set.sub request to update current subscription or invite another user, {sub.what} == "sub"
type SetSub struct {
	// User affected by this request. Default (empty): current user
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Access mode change, either Given or Want depending on context
	Mode string `protobuf:"bytes,2,opt,name=mode" json:"mode,omitempty"`
}

func (m *SetSub) Reset()                    { *m = SetSub{} }
func (m *SetSub) String() string            { return proto.CompactTextString(m) }
func (*SetSub) ProtoMessage()               {}
func (*SetSub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SetSub) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *SetSub) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

// SetDesc: C2S in set.what == "desc" and sub.init message
type SetDesc struct {
	DefaultAcs *DefaultAcsMode `protobuf:"bytes,1,opt,name=default_acs,json=defaultAcs" json:"default_acs,omitempty"`
	Public     []byte          `protobuf:"bytes,2,opt,name=public,proto3" json:"public,omitempty"`
	Private    []byte          `protobuf:"bytes,3,opt,name=private,proto3" json:"private,omitempty"`
}

func (m *SetDesc) Reset()                    { *m = SetDesc{} }
func (m *SetDesc) String() string            { return proto.CompactTextString(m) }
func (*SetDesc) ProtoMessage()               {}
func (*SetDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SetDesc) GetDefaultAcs() *DefaultAcsMode {
	if m != nil {
		return m.DefaultAcs
	}
	return nil
}

func (m *SetDesc) GetPublic() []byte {
	if m != nil {
		return m.Public
	}
	return nil
}

func (m *SetDesc) GetPrivate() []byte {
	if m != nil {
		return m.Private
	}
	return nil
}

type GetOpts struct {
	IfModifiedSince int64 `protobuf:"varint,1,opt,name=if_modified_since,json=ifModifiedSince" json:"if_modified_since,omitempty"`
	Limit           int32 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
}

func (m *GetOpts) Reset()                    { *m = GetOpts{} }
func (m *GetOpts) String() string            { return proto.CompactTextString(m) }
func (*GetOpts) ProtoMessage()               {}
func (*GetOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetOpts) GetIfModifiedSince() int64 {
	if m != nil {
		return m.IfModifiedSince
	}
	return 0
}

func (m *GetOpts) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type BrowseOpts struct {
	// Load messages with seq id equal or greater than this
	SinceId int32 `protobuf:"varint,1,opt,name=since_id,json=sinceId" json:"since_id,omitempty"`
	// Load messages with UpdatedAt equal or grater than this
	SinceTs int64 `protobuf:"varint,2,opt,name=since_ts,json=sinceTs" json:"since_ts,omitempty"`
	// Load messages with seq id lower than this
	BeforeId int32 `protobuf:"varint,3,opt,name=before_id,json=beforeId" json:"before_id,omitempty"`
	// Load messages with UpdatedAt lower than this
	BeforeTs int64 `protobuf:"varint,4,opt,name=before_ts,json=beforeTs" json:"before_ts,omitempty"`
	// Limit the number of messages loaded
	Limit int32 `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
}

func (m *BrowseOpts) Reset()                    { *m = BrowseOpts{} }
func (m *BrowseOpts) String() string            { return proto.CompactTextString(m) }
func (*BrowseOpts) ProtoMessage()               {}
func (*BrowseOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *BrowseOpts) GetSinceId() int32 {
	if m != nil {
		return m.SinceId
	}
	return 0
}

func (m *BrowseOpts) GetSinceTs() int64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

func (m *BrowseOpts) GetBeforeId() int32 {
	if m != nil {
		return m.BeforeId
	}
	return 0
}

func (m *BrowseOpts) GetBeforeTs() int64 {
	if m != nil {
		return m.BeforeTs
	}
	return 0
}

func (m *BrowseOpts) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetQuery struct {
	What string `protobuf:"bytes,1,opt,name=what" json:"what,omitempty"`
	// Parameters of "desc" request
	Desc *GetOpts `protobuf:"bytes,2,opt,name=desc" json:"desc,omitempty"`
	// Parameters of "sub" request
	Sub *GetOpts `protobuf:"bytes,3,opt,name=sub" json:"sub,omitempty"`
	// Parameters of "data" request
	Data *BrowseOpts `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
}

func (m *GetQuery) Reset()                    { *m = GetQuery{} }
func (m *GetQuery) String() string            { return proto.CompactTextString(m) }
func (*GetQuery) ProtoMessage()               {}
func (*GetQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetQuery) GetWhat() string {
	if m != nil {
		return m.What
	}
	return ""
}

func (m *GetQuery) GetDesc() *GetOpts {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *GetQuery) GetSub() *GetOpts {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *GetQuery) GetData() *BrowseOpts {
	if m != nil {
		return m.Data
	}
	return nil
}

type SetQuery struct {
	// Topic metadata, new topic & new subscriptions only
	Desc *SetDesc `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// Subscription parameters
	Sub *SetSub `protobuf:"bytes,2,opt,name=sub" json:"sub,omitempty"`
}

func (m *SetQuery) Reset()                    { *m = SetQuery{} }
func (m *SetQuery) String() string            { return proto.CompactTextString(m) }
func (*SetQuery) ProtoMessage()               {}
func (*SetQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SetQuery) GetDesc() *SetDesc {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *SetQuery) GetSub() *SetSub {
	if m != nil {
		return m.Sub
	}
	return nil
}

// Client handshake
type ClientHi struct {
	Id        string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	UserAgent string `protobuf:"bytes,2,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	Ver       int32  `protobuf:"varint,3,opt,name=ver" json:"ver,omitempty"`
	DeviceId  string `protobuf:"bytes,4,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	Lang      string `protobuf:"bytes,5,opt,name=lang" json:"lang,omitempty"`
}

func (m *ClientHi) Reset()                    { *m = ClientHi{} }
func (m *ClientHi) String() string            { return proto.CompactTextString(m) }
func (*ClientHi) ProtoMessage()               {}
func (*ClientHi) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ClientHi) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientHi) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *ClientHi) GetVer() int32 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *ClientHi) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *ClientHi) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

// User creation message {acc}
type ClientAcc struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User being created or updated
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// The initial authentication scheme the account can use
	Scheme string `protobuf:"bytes,3,opt,name=scheme" json:"scheme,omitempty"`
	// Shared secret
	Secret []byte `protobuf:"bytes,4,opt,name=secret,proto3" json:"secret,omitempty"`
	// Authenticate session with the newly created account
	Login bool `protobuf:"varint,5,opt,name=login" json:"login,omitempty"`
	// Indexable tags for user discovery
	Tags []string `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	// User initialization data when creating a new user, otherwise ignored
	Desc *SetDesc `protobuf:"bytes,7,opt,name=desc" json:"desc,omitempty"`
}

func (m *ClientAcc) Reset()                    { *m = ClientAcc{} }
func (m *ClientAcc) String() string            { return proto.CompactTextString(m) }
func (*ClientAcc) ProtoMessage()               {}
func (*ClientAcc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ClientAcc) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientAcc) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *ClientAcc) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *ClientAcc) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *ClientAcc) GetLogin() bool {
	if m != nil {
		return m.Login
	}
	return false
}

func (m *ClientAcc) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ClientAcc) GetDesc() *SetDesc {
	if m != nil {
		return m.Desc
	}
	return nil
}

// Login {login} message
type ClientLogin struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Authentication scheme
	Scheme string `protobuf:"bytes,2,opt,name=scheme" json:"scheme,omitempty"`
	// Shared secret
	Secret []byte `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *ClientLogin) Reset()                    { *m = ClientLogin{} }
func (m *ClientLogin) String() string            { return proto.CompactTextString(m) }
func (*ClientLogin) ProtoMessage()               {}
func (*ClientLogin) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ClientLogin) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientLogin) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *ClientLogin) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

// Subscription request {sub} message
type ClientSub struct {
	Id    string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// mirrors {set}
	SetQuery *SetQuery `protobuf:"bytes,3,opt,name=set_query,json=setQuery" json:"set_query,omitempty"`
	// mirrors {get}
	GetQuery *GetQuery `protobuf:"bytes,4,opt,name=get_query,json=getQuery" json:"get_query,omitempty"`
}

func (m *ClientSub) Reset()                    { *m = ClientSub{} }
func (m *ClientSub) String() string            { return proto.CompactTextString(m) }
func (*ClientSub) ProtoMessage()               {}
func (*ClientSub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ClientSub) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientSub) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientSub) GetSetQuery() *SetQuery {
	if m != nil {
		return m.SetQuery
	}
	return nil
}

func (m *ClientSub) GetGetQuery() *GetQuery {
	if m != nil {
		return m.GetQuery
	}
	return nil
}

// Unsubscribe {leave} request message
type ClientLeave struct {
	Id    string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	Unsub bool   `protobuf:"varint,3,opt,name=unsub" json:"unsub,omitempty"`
}

func (m *ClientLeave) Reset()                    { *m = ClientLeave{} }
func (m *ClientLeave) String() string            { return proto.CompactTextString(m) }
func (*ClientLeave) ProtoMessage()               {}
func (*ClientLeave) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ClientLeave) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientLeave) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientLeave) GetUnsub() bool {
	if m != nil {
		return m.Unsub
	}
	return false
}

// ClientPub is client's request to publish data to topic subscribers {pub}
type ClientPub struct {
	Id      string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic   string            `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	NoEcho  bool              `protobuf:"varint,3,opt,name=no_echo,json=noEcho" json:"no_echo,omitempty"`
	Head    map[string]string `protobuf:"bytes,4,rep,name=head" json:"head,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Content []byte            `protobuf:"bytes,5,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ClientPub) Reset()                    { *m = ClientPub{} }
func (m *ClientPub) String() string            { return proto.CompactTextString(m) }
func (*ClientPub) ProtoMessage()               {}
func (*ClientPub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ClientPub) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientPub) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientPub) GetNoEcho() bool {
	if m != nil {
		return m.NoEcho
	}
	return false
}

func (m *ClientPub) GetHead() map[string]string {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *ClientPub) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// Query topic state {get}
type ClientGet struct {
	Id    string    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string    `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	Query *GetQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
}

func (m *ClientGet) Reset()                    { *m = ClientGet{} }
func (m *ClientGet) String() string            { return proto.CompactTextString(m) }
func (*ClientGet) ProtoMessage()               {}
func (*ClientGet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ClientGet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientGet) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientGet) GetQuery() *GetQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// Update topic state {set}
type ClientSet struct {
	Id    string    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string    `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	Query *SetQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
}

func (m *ClientSet) Reset()                    { *m = ClientSet{} }
func (m *ClientSet) String() string            { return proto.CompactTextString(m) }
func (*ClientSet) ProtoMessage()               {}
func (*ClientSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ClientSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientSet) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientSet) GetQuery() *SetQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ClientDel delete messages or topic
type ClientDel struct {
	Id    string         `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string         `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	What  ClientDel_What `protobuf:"varint,3,opt,name=what,enum=pbx.ClientDel_What" json:"what,omitempty"`
	// Delete messages older than this seq ID (inclusive)
	Before int32 `protobuf:"varint,4,opt,name=before" json:"before,omitempty"`
	// List of Seq Ids to delete/mark as deleted
	SeqList []int32 `protobuf:"varint,5,rep,packed,name=seq_list,json=seqList" json:"seq_list,omitempty"`
	// User ID of the subscription to delete
	UserId string `protobuf:"bytes,6,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Request to hard-delete messages for all users, if such option is available.
	Hard bool `protobuf:"varint,7,opt,name=hard" json:"hard,omitempty"`
}

func (m *ClientDel) Reset()                    { *m = ClientDel{} }
func (m *ClientDel) String() string            { return proto.CompactTextString(m) }
func (*ClientDel) ProtoMessage()               {}
func (*ClientDel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ClientDel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClientDel) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientDel) GetWhat() ClientDel_What {
	if m != nil {
		return m.What
	}
	return ClientDel_MSG
}

func (m *ClientDel) GetBefore() int32 {
	if m != nil {
		return m.Before
	}
	return 0
}

func (m *ClientDel) GetSeqList() []int32 {
	if m != nil {
		return m.SeqList
	}
	return nil
}

func (m *ClientDel) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *ClientDel) GetHard() bool {
	if m != nil {
		return m.Hard
	}
	return false
}

// ClientNote is a client-generated notification for topic subscribers
type ClientNote struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	// what is being reported: "recv" - message received, "read" - message read, "kp" - typing notification
	What InfoNote `protobuf:"varint,2,opt,name=what,enum=pbx.InfoNote" json:"what,omitempty"`
	// Server-issued message ID being reported
	SeqId int32 `protobuf:"varint,3,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
}

func (m *ClientNote) Reset()                    { *m = ClientNote{} }
func (m *ClientNote) String() string            { return proto.CompactTextString(m) }
func (*ClientNote) ProtoMessage()               {}
func (*ClientNote) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ClientNote) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ClientNote) GetWhat() InfoNote {
	if m != nil {
		return m.What
	}
	return InfoNote_READ
}

func (m *ClientNote) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

type ClientMsg struct {
	// Types that are valid to be assigned to Message:
	//	*ClientMsg_Hi
	//	*ClientMsg_Acc
	//	*ClientMsg_Login
	//	*ClientMsg_Sub
	//	*ClientMsg_Leave
	//	*ClientMsg_Pub
	//	*ClientMsg_Get
	//	*ClientMsg_Set
	//	*ClientMsg_Del
	//	*ClientMsg_Note
	Message isClientMsg_Message `protobuf_oneof:"Message"`
}

func (m *ClientMsg) Reset()                    { *m = ClientMsg{} }
func (m *ClientMsg) String() string            { return proto.CompactTextString(m) }
func (*ClientMsg) ProtoMessage()               {}
func (*ClientMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type isClientMsg_Message interface {
	isClientMsg_Message()
}

type ClientMsg_Hi struct {
	Hi *ClientHi `protobuf:"bytes,1,opt,name=hi,oneof"`
}
type ClientMsg_Acc struct {
	Acc *ClientAcc `protobuf:"bytes,2,opt,name=acc,oneof"`
}
type ClientMsg_Login struct {
	Login *ClientLogin `protobuf:"bytes,3,opt,name=login,oneof"`
}
type ClientMsg_Sub struct {
	Sub *ClientSub `protobuf:"bytes,4,opt,name=sub,oneof"`
}
type ClientMsg_Leave struct {
	Leave *ClientLeave `protobuf:"bytes,5,opt,name=leave,oneof"`
}
type ClientMsg_Pub struct {
	Pub *ClientPub `protobuf:"bytes,6,opt,name=pub,oneof"`
}
type ClientMsg_Get struct {
	Get *ClientGet `protobuf:"bytes,7,opt,name=get,oneof"`
}
type ClientMsg_Set struct {
	Set *ClientSet `protobuf:"bytes,8,opt,name=set,oneof"`
}
type ClientMsg_Del struct {
	Del *ClientDel `protobuf:"bytes,9,opt,name=del,oneof"`
}
type ClientMsg_Note struct {
	Note *ClientNote `protobuf:"bytes,10,opt,name=note,oneof"`
}

func (*ClientMsg_Hi) isClientMsg_Message()    {}
func (*ClientMsg_Acc) isClientMsg_Message()   {}
func (*ClientMsg_Login) isClientMsg_Message() {}
func (*ClientMsg_Sub) isClientMsg_Message()   {}
func (*ClientMsg_Leave) isClientMsg_Message() {}
func (*ClientMsg_Pub) isClientMsg_Message()   {}
func (*ClientMsg_Get) isClientMsg_Message()   {}
func (*ClientMsg_Set) isClientMsg_Message()   {}
func (*ClientMsg_Del) isClientMsg_Message()   {}
func (*ClientMsg_Note) isClientMsg_Message()  {}

func (m *ClientMsg) GetMessage() isClientMsg_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ClientMsg) GetHi() *ClientHi {
	if x, ok := m.GetMessage().(*ClientMsg_Hi); ok {
		return x.Hi
	}
	return nil
}

func (m *ClientMsg) GetAcc() *ClientAcc {
	if x, ok := m.GetMessage().(*ClientMsg_Acc); ok {
		return x.Acc
	}
	return nil
}

func (m *ClientMsg) GetLogin() *ClientLogin {
	if x, ok := m.GetMessage().(*ClientMsg_Login); ok {
		return x.Login
	}
	return nil
}

func (m *ClientMsg) GetSub() *ClientSub {
	if x, ok := m.GetMessage().(*ClientMsg_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *ClientMsg) GetLeave() *ClientLeave {
	if x, ok := m.GetMessage().(*ClientMsg_Leave); ok {
		return x.Leave
	}
	return nil
}

func (m *ClientMsg) GetPub() *ClientPub {
	if x, ok := m.GetMessage().(*ClientMsg_Pub); ok {
		return x.Pub
	}
	return nil
}

func (m *ClientMsg) GetGet() *ClientGet {
	if x, ok := m.GetMessage().(*ClientMsg_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ClientMsg) GetSet() *ClientSet {
	if x, ok := m.GetMessage().(*ClientMsg_Set); ok {
		return x.Set
	}
	return nil
}

func (m *ClientMsg) GetDel() *ClientDel {
	if x, ok := m.GetMessage().(*ClientMsg_Del); ok {
		return x.Del
	}
	return nil
}

func (m *ClientMsg) GetNote() *ClientNote {
	if x, ok := m.GetMessage().(*ClientMsg_Note); ok {
		return x.Note
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientMsg_OneofMarshaler, _ClientMsg_OneofUnmarshaler, _ClientMsg_OneofSizer, []interface{}{
		(*ClientMsg_Hi)(nil),
		(*ClientMsg_Acc)(nil),
		(*ClientMsg_Login)(nil),
		(*ClientMsg_Sub)(nil),
		(*ClientMsg_Leave)(nil),
		(*ClientMsg_Pub)(nil),
		(*ClientMsg_Get)(nil),
		(*ClientMsg_Set)(nil),
		(*ClientMsg_Del)(nil),
		(*ClientMsg_Note)(nil),
	}
}

func _ClientMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientMsg)
	// Message
	switch x := m.Message.(type) {
	case *ClientMsg_Hi:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hi); err != nil {
			return err
		}
	case *ClientMsg_Acc:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Acc); err != nil {
			return err
		}
	case *ClientMsg_Login:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Login); err != nil {
			return err
		}
	case *ClientMsg_Sub:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sub); err != nil {
			return err
		}
	case *ClientMsg_Leave:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Leave); err != nil {
			return err
		}
	case *ClientMsg_Pub:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pub); err != nil {
			return err
		}
	case *ClientMsg_Get:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Get); err != nil {
			return err
		}
	case *ClientMsg_Set:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Set); err != nil {
			return err
		}
	case *ClientMsg_Del:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Del); err != nil {
			return err
		}
	case *ClientMsg_Note:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Note); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientMsg.Message has unexpected type %T", x)
	}
	return nil
}

func _ClientMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientMsg)
	switch tag {
	case 1: // Message.hi
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientHi)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Hi{msg}
		return true, err
	case 2: // Message.acc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientAcc)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Acc{msg}
		return true, err
	case 3: // Message.login
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientLogin)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Login{msg}
		return true, err
	case 4: // Message.sub
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientSub)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Sub{msg}
		return true, err
	case 5: // Message.leave
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientLeave)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Leave{msg}
		return true, err
	case 6: // Message.pub
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientPub)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Pub{msg}
		return true, err
	case 7: // Message.get
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientGet)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Get{msg}
		return true, err
	case 8: // Message.set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientSet)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Set{msg}
		return true, err
	case 9: // Message.del
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientDel)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Del{msg}
		return true, err
	case 10: // Message.note
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientNote)
		err := b.DecodeMessage(msg)
		m.Message = &ClientMsg_Note{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientMsg)
	// Message
	switch x := m.Message.(type) {
	case *ClientMsg_Hi:
		s := proto.Size(x.Hi)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Acc:
		s := proto.Size(x.Acc)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Login:
		s := proto.Size(x.Login)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Sub:
		s := proto.Size(x.Sub)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Leave:
		s := proto.Size(x.Leave)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Pub:
		s := proto.Size(x.Pub)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Get:
		s := proto.Size(x.Get)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Set:
		s := proto.Size(x.Set)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Del:
		s := proto.Size(x.Del)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Note:
		s := proto.Size(x.Note)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Topic description, S2C in Meta message
type TopicDesc struct {
	CreatedAt int64           `protobuf:"varint,1,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	UpdatedAt int64           `protobuf:"varint,2,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	Defacs    *DefaultAcsMode `protobuf:"bytes,4,opt,name=defacs" json:"defacs,omitempty"`
	Acs       *AccessMode     `protobuf:"bytes,5,opt,name=acs" json:"acs,omitempty"`
	SeqId     int32           `protobuf:"varint,6,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	ReadId    int32           `protobuf:"varint,7,opt,name=read_id,json=readId" json:"read_id,omitempty"`
	RecvId    int32           `protobuf:"varint,8,opt,name=recv_id,json=recvId" json:"recv_id,omitempty"`
	ClearId   int32           `protobuf:"varint,9,opt,name=clear_id,json=clearId" json:"clear_id,omitempty"`
	Public    []byte          `protobuf:"bytes,10,opt,name=public,proto3" json:"public,omitempty"`
	Private   []byte          `protobuf:"bytes,11,opt,name=private,proto3" json:"private,omitempty"`
}

func (m *TopicDesc) Reset()                    { *m = TopicDesc{} }
func (m *TopicDesc) String() string            { return proto.CompactTextString(m) }
func (*TopicDesc) ProtoMessage()               {}
func (*TopicDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *TopicDesc) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TopicDesc) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TopicDesc) GetDefacs() *DefaultAcsMode {
	if m != nil {
		return m.Defacs
	}
	return nil
}

func (m *TopicDesc) GetAcs() *AccessMode {
	if m != nil {
		return m.Acs
	}
	return nil
}

func (m *TopicDesc) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *TopicDesc) GetReadId() int32 {
	if m != nil {
		return m.ReadId
	}
	return 0
}

func (m *TopicDesc) GetRecvId() int32 {
	if m != nil {
		return m.RecvId
	}
	return 0
}

func (m *TopicDesc) GetClearId() int32 {
	if m != nil {
		return m.ClearId
	}
	return 0
}

func (m *TopicDesc) GetPublic() []byte {
	if m != nil {
		return m.Public
	}
	return nil
}

func (m *TopicDesc) GetPrivate() []byte {
	if m != nil {
		return m.Private
	}
	return nil
}

// MsgTopicSub: topic subscription details, sent in Meta message
type TopicSub struct {
	UpdatedAt int64       `protobuf:"varint,1,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	DeletedAt int64       `protobuf:"varint,2,opt,name=deleted_at,json=deletedAt" json:"deleted_at,omitempty"`
	Online    bool        `protobuf:"varint,3,opt,name=online" json:"online,omitempty"`
	Acs       *AccessMode `protobuf:"bytes,4,opt,name=acs" json:"acs,omitempty"`
	ReadId    int32       `protobuf:"varint,5,opt,name=read_id,json=readId" json:"read_id,omitempty"`
	RecvId    int32       `protobuf:"varint,6,opt,name=recv_id,json=recvId" json:"recv_id,omitempty"`
	Public    []byte      `protobuf:"bytes,7,opt,name=public,proto3" json:"public,omitempty"`
	Private   []byte      `protobuf:"bytes,8,opt,name=private,proto3" json:"private,omitempty"`
	// Uid of the subscribed user
	UserId string `protobuf:"bytes,9,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Topic name of this subscription
	Topic string `protobuf:"bytes,10,opt,name=topic" json:"topic,omitempty"`
	// ID of the last {data} message in a topic
	SeqId int32 `protobuf:"varint,11,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	// Messages are deleted up to this ID
	ClearId int32 `protobuf:"varint,12,opt,name=clear_id,json=clearId" json:"clear_id,omitempty"`
	// Other user's last online timestamp & user agent
	LastSeenTime      int64  `protobuf:"varint,13,opt,name=last_seen_time,json=lastSeenTime" json:"last_seen_time,omitempty"`
	LastSeenUserAgent string `protobuf:"bytes,14,opt,name=last_seen_user_agent,json=lastSeenUserAgent" json:"last_seen_user_agent,omitempty"`
}

func (m *TopicSub) Reset()                    { *m = TopicSub{} }
func (m *TopicSub) String() string            { return proto.CompactTextString(m) }
func (*TopicSub) ProtoMessage()               {}
func (*TopicSub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *TopicSub) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TopicSub) GetDeletedAt() int64 {
	if m != nil {
		return m.DeletedAt
	}
	return 0
}

func (m *TopicSub) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *TopicSub) GetAcs() *AccessMode {
	if m != nil {
		return m.Acs
	}
	return nil
}

func (m *TopicSub) GetReadId() int32 {
	if m != nil {
		return m.ReadId
	}
	return 0
}

func (m *TopicSub) GetRecvId() int32 {
	if m != nil {
		return m.RecvId
	}
	return 0
}

func (m *TopicSub) GetPublic() []byte {
	if m != nil {
		return m.Public
	}
	return nil
}

func (m *TopicSub) GetPrivate() []byte {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *TopicSub) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *TopicSub) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicSub) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *TopicSub) GetClearId() int32 {
	if m != nil {
		return m.ClearId
	}
	return 0
}

func (m *TopicSub) GetLastSeenTime() int64 {
	if m != nil {
		return m.LastSeenTime
	}
	return 0
}

func (m *TopicSub) GetLastSeenUserAgent() string {
	if m != nil {
		return m.LastSeenUserAgent
	}
	return ""
}

// {ctrl} message
type ServerCtrl struct {
	Id     string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Code   int32             `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Text   string            `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	Params map[string][]byte `protobuf:"bytes,4,rep,name=params" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ServerCtrl) Reset()                    { *m = ServerCtrl{} }
func (m *ServerCtrl) String() string            { return proto.CompactTextString(m) }
func (*ServerCtrl) ProtoMessage()               {}
func (*ServerCtrl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ServerCtrl) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServerCtrl) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ServerCtrl) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ServerCtrl) GetParams() map[string][]byte {
	if m != nil {
		return m.Params
	}
	return nil
}

// {data} message
type ServerData struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	// ID of the user who originated the message as {pub}, could be empty if sent by the system
	FromUserId string `protobuf:"bytes,2,opt,name=from_user_id,json=fromUserId" json:"from_user_id,omitempty"`
	// Timestamp when the message was deleted or 0. Milliseconds since the epoch 01/01/1970
	DeletedAt int64             `protobuf:"varint,3,opt,name=deleted_at,json=deletedAt" json:"deleted_at,omitempty"`
	SeqId     int32             `protobuf:"varint,4,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	Head      map[string]string `protobuf:"bytes,5,rep,name=head" json:"head,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Content   []byte            `protobuf:"bytes,6,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ServerData) Reset()                    { *m = ServerData{} }
func (m *ServerData) String() string            { return proto.CompactTextString(m) }
func (*ServerData) ProtoMessage()               {}
func (*ServerData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ServerData) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ServerData) GetFromUserId() string {
	if m != nil {
		return m.FromUserId
	}
	return ""
}

func (m *ServerData) GetDeletedAt() int64 {
	if m != nil {
		return m.DeletedAt
	}
	return 0
}

func (m *ServerData) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *ServerData) GetHead() map[string]string {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *ServerData) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// {pres} message
type ServerPres struct {
	Topic        string          `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Src          string          `protobuf:"bytes,2,opt,name=src" json:"src,omitempty"`
	What         ServerPres_What `protobuf:"varint,3,opt,name=what,enum=pbx.ServerPres_What" json:"what,omitempty"`
	UserAgent    string          `protobuf:"bytes,4,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	SeqId        int32           `protobuf:"varint,5,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
	SeqList      []int32         `protobuf:"varint,6,rep,packed,name=seq_list,json=seqList" json:"seq_list,omitempty"`
	TargetUserId string          `protobuf:"bytes,7,opt,name=target_user_id,json=targetUserId" json:"target_user_id,omitempty"`
	ActorUserId  string          `protobuf:"bytes,8,opt,name=actor_user_id,json=actorUserId" json:"actor_user_id,omitempty"`
	Acs          *AccessMode     `protobuf:"bytes,9,opt,name=acs" json:"acs,omitempty"`
}

func (m *ServerPres) Reset()                    { *m = ServerPres{} }
func (m *ServerPres) String() string            { return proto.CompactTextString(m) }
func (*ServerPres) ProtoMessage()               {}
func (*ServerPres) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ServerPres) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ServerPres) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *ServerPres) GetWhat() ServerPres_What {
	if m != nil {
		return m.What
	}
	return ServerPres_ON
}

func (m *ServerPres) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *ServerPres) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *ServerPres) GetSeqList() []int32 {
	if m != nil {
		return m.SeqList
	}
	return nil
}

func (m *ServerPres) GetTargetUserId() string {
	if m != nil {
		return m.TargetUserId
	}
	return ""
}

func (m *ServerPres) GetActorUserId() string {
	if m != nil {
		return m.ActorUserId
	}
	return ""
}

func (m *ServerPres) GetAcs() *AccessMode {
	if m != nil {
		return m.Acs
	}
	return nil
}

// {meta} message
type ServerMeta struct {
	Id    string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Topic string      `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	Desc  *TopicDesc  `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
	Sub   []*TopicSub `protobuf:"bytes,4,rep,name=sub" json:"sub,omitempty"`
}

func (m *ServerMeta) Reset()                    { *m = ServerMeta{} }
func (m *ServerMeta) String() string            { return proto.CompactTextString(m) }
func (*ServerMeta) ProtoMessage()               {}
func (*ServerMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ServerMeta) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServerMeta) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ServerMeta) GetDesc() *TopicDesc {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *ServerMeta) GetSub() []*TopicSub {
	if m != nil {
		return m.Sub
	}
	return nil
}

// {info} message: server-side copy of ClientNote with From added
type ServerInfo struct {
	Topic      string   `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	FromUserId string   `protobuf:"bytes,2,opt,name=from_user_id,json=fromUserId" json:"from_user_id,omitempty"`
	What       InfoNote `protobuf:"varint,3,opt,name=what,enum=pbx.InfoNote" json:"what,omitempty"`
	SeqId      int32    `protobuf:"varint,4,opt,name=seq_id,json=seqId" json:"seq_id,omitempty"`
}

func (m *ServerInfo) Reset()                    { *m = ServerInfo{} }
func (m *ServerInfo) String() string            { return proto.CompactTextString(m) }
func (*ServerInfo) ProtoMessage()               {}
func (*ServerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ServerInfo) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ServerInfo) GetFromUserId() string {
	if m != nil {
		return m.FromUserId
	}
	return ""
}

func (m *ServerInfo) GetWhat() InfoNote {
	if m != nil {
		return m.What
	}
	return InfoNote_READ
}

func (m *ServerInfo) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

// Cumulative message
type ServerMsg struct {
	// Types that are valid to be assigned to Message:
	//	*ServerMsg_Ctrl
	//	*ServerMsg_Data
	//	*ServerMsg_Pres
	//	*ServerMsg_Meta
	//	*ServerMsg_Info
	Message isServerMsg_Message `protobuf_oneof:"Message"`
}

func (m *ServerMsg) Reset()                    { *m = ServerMsg{} }
func (m *ServerMsg) String() string            { return proto.CompactTextString(m) }
func (*ServerMsg) ProtoMessage()               {}
func (*ServerMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type isServerMsg_Message interface {
	isServerMsg_Message()
}

type ServerMsg_Ctrl struct {
	Ctrl *ServerCtrl `protobuf:"bytes,1,opt,name=ctrl,oneof"`
}
type ServerMsg_Data struct {
	Data *ServerData `protobuf:"bytes,2,opt,name=data,oneof"`
}
type ServerMsg_Pres struct {
	Pres *ServerPres `protobuf:"bytes,3,opt,name=pres,oneof"`
}
type ServerMsg_Meta struct {
	Meta *ServerMeta `protobuf:"bytes,4,opt,name=meta,oneof"`
}
type ServerMsg_Info struct {
	Info *ServerInfo `protobuf:"bytes,5,opt,name=info,oneof"`
}

func (*ServerMsg_Ctrl) isServerMsg_Message() {}
func (*ServerMsg_Data) isServerMsg_Message() {}
func (*ServerMsg_Pres) isServerMsg_Message() {}
func (*ServerMsg_Meta) isServerMsg_Message() {}
func (*ServerMsg_Info) isServerMsg_Message() {}

func (m *ServerMsg) GetMessage() isServerMsg_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ServerMsg) GetCtrl() *ServerCtrl {
	if x, ok := m.GetMessage().(*ServerMsg_Ctrl); ok {
		return x.Ctrl
	}
	return nil
}

func (m *ServerMsg) GetData() *ServerData {
	if x, ok := m.GetMessage().(*ServerMsg_Data); ok {
		return x.Data
	}
	return nil
}

func (m *ServerMsg) GetPres() *ServerPres {
	if x, ok := m.GetMessage().(*ServerMsg_Pres); ok {
		return x.Pres
	}
	return nil
}

func (m *ServerMsg) GetMeta() *ServerMeta {
	if x, ok := m.GetMessage().(*ServerMsg_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *ServerMsg) GetInfo() *ServerInfo {
	if x, ok := m.GetMessage().(*ServerMsg_Info); ok {
		return x.Info
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServerMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServerMsg_OneofMarshaler, _ServerMsg_OneofUnmarshaler, _ServerMsg_OneofSizer, []interface{}{
		(*ServerMsg_Ctrl)(nil),
		(*ServerMsg_Data)(nil),
		(*ServerMsg_Pres)(nil),
		(*ServerMsg_Meta)(nil),
		(*ServerMsg_Info)(nil),
	}
}

func _ServerMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServerMsg)
	// Message
	switch x := m.Message.(type) {
	case *ServerMsg_Ctrl:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ctrl); err != nil {
			return err
		}
	case *ServerMsg_Data:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case *ServerMsg_Pres:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pres); err != nil {
			return err
		}
	case *ServerMsg_Meta:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *ServerMsg_Info:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServerMsg.Message has unexpected type %T", x)
	}
	return nil
}

func _ServerMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServerMsg)
	switch tag {
	case 1: // Message.ctrl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerCtrl)
		err := b.DecodeMessage(msg)
		m.Message = &ServerMsg_Ctrl{msg}
		return true, err
	case 2: // Message.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerData)
		err := b.DecodeMessage(msg)
		m.Message = &ServerMsg_Data{msg}
		return true, err
	case 3: // Message.pres
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerPres)
		err := b.DecodeMessage(msg)
		m.Message = &ServerMsg_Pres{msg}
		return true, err
	case 4: // Message.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerMeta)
		err := b.DecodeMessage(msg)
		m.Message = &ServerMsg_Meta{msg}
		return true, err
	case 5: // Message.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerInfo)
		err := b.DecodeMessage(msg)
		m.Message = &ServerMsg_Info{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServerMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServerMsg)
	// Message
	switch x := m.Message.(type) {
	case *ServerMsg_Ctrl:
		s := proto.Size(x.Ctrl)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_Data:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_Pres:
		s := proto.Size(x.Pres)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_Meta:
		s := proto.Size(x.Meta)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_Info:
		s := proto.Size(x.Info)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServerResp struct {
	Status ServerResp_RespCode `protobuf:"varint,1,opt,name=status,enum=pbx.ServerResp_RespCode" json:"status,omitempty"`
	Srvmsg *ServerMsg          `protobuf:"bytes,2,opt,name=srvmsg" json:"srvmsg,omitempty"`
	Clmsg  *ClientMsg          `protobuf:"bytes,3,opt,name=clmsg" json:"clmsg,omitempty"`
}

func (m *ServerResp) Reset()                    { *m = ServerResp{} }
func (m *ServerResp) String() string            { return proto.CompactTextString(m) }
func (*ServerResp) ProtoMessage()               {}
func (*ServerResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ServerResp) GetStatus() ServerResp_RespCode {
	if m != nil {
		return m.Status
	}
	return ServerResp_CONTINUE
}

func (m *ServerResp) GetSrvmsg() *ServerMsg {
	if m != nil {
		return m.Srvmsg
	}
	return nil
}

func (m *ServerResp) GetClmsg() *ClientMsg {
	if m != nil {
		return m.Clmsg
	}
	return nil
}

// Context message
type Session struct {
	SessionId  string            `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	UserId     string            `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	AuthLevel  Session_AuthLevel `protobuf:"varint,3,opt,name=auth_level,json=authLevel,enum=pbx.Session_AuthLevel" json:"auth_level,omitempty"`
	RemoteAddr string            `protobuf:"bytes,4,opt,name=remote_addr,json=remoteAddr" json:"remote_addr,omitempty"`
	UserAgent  string            `protobuf:"bytes,5,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	DeviceId   string            `protobuf:"bytes,6,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	Language   string            `protobuf:"bytes,7,opt,name=language" json:"language,omitempty"`
}

func (m *Session) Reset()                    { *m = Session{} }
func (m *Session) String() string            { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()               {}
func (*Session) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *Session) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Session) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Session) GetAuthLevel() Session_AuthLevel {
	if m != nil {
		return m.AuthLevel
	}
	return Session_NONE
}

func (m *Session) GetRemoteAddr() string {
	if m != nil {
		return m.RemoteAddr
	}
	return ""
}

func (m *Session) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *Session) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *Session) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

type ClientReq struct {
	Msg  *ClientMsg `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	Sess *Session   `protobuf:"bytes,2,opt,name=sess" json:"sess,omitempty"`
}

func (m *ClientReq) Reset()                    { *m = ClientReq{} }
func (m *ClientReq) String() string            { return proto.CompactTextString(m) }
func (*ClientReq) ProtoMessage()               {}
func (*ClientReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ClientReq) GetMsg() *ClientMsg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ClientReq) GetSess() *Session {
	if m != nil {
		return m.Sess
	}
	return nil
}

type TopicEvent struct {
	Action Crud       `protobuf:"varint,1,opt,name=action,enum=pbx.Crud" json:"action,omitempty"`
	Name   string     `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Desc   *TopicDesc `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
}

func (m *TopicEvent) Reset()                    { *m = TopicEvent{} }
func (m *TopicEvent) String() string            { return proto.CompactTextString(m) }
func (*TopicEvent) ProtoMessage()               {}
func (*TopicEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *TopicEvent) GetAction() Crud {
	if m != nil {
		return m.Action
	}
	return Crud_CREATE
}

func (m *TopicEvent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicEvent) GetDesc() *TopicDesc {
	if m != nil {
		return m.Desc
	}
	return nil
}

type AccountEvent struct {
	Action      Crud                       `protobuf:"varint,1,opt,name=action,enum=pbx.Crud" json:"action,omitempty"`
	UserId      string                     `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	DefaultAcs  *DefaultAcsMode            `protobuf:"bytes,3,opt,name=default_acs,json=defaultAcs" json:"default_acs,omitempty"`
	Public      []byte                     `protobuf:"bytes,4,opt,name=public,proto3" json:"public,omitempty"`
	Private     []byte                     `protobuf:"bytes,5,opt,name=private,proto3" json:"private,omitempty"`
	LastSeen    int64                      `protobuf:"varint,6,opt,name=last_seen,json=lastSeen" json:"last_seen,omitempty"`
	UserAgent   string                     `protobuf:"bytes,7,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	AuthSchemes []*AccountEvent_AuthScheme `protobuf:"bytes,8,rep,name=auth_schemes,json=authSchemes" json:"auth_schemes,omitempty"`
	// Indexable tags for user discovery
	Tags []string `protobuf:"bytes,9,rep,name=tags" json:"tags,omitempty"`
}

func (m *AccountEvent) Reset()                    { *m = AccountEvent{} }
func (m *AccountEvent) String() string            { return proto.CompactTextString(m) }
func (*AccountEvent) ProtoMessage()               {}
func (*AccountEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *AccountEvent) GetAction() Crud {
	if m != nil {
		return m.Action
	}
	return Crud_CREATE
}

func (m *AccountEvent) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *AccountEvent) GetDefaultAcs() *DefaultAcsMode {
	if m != nil {
		return m.DefaultAcs
	}
	return nil
}

func (m *AccountEvent) GetPublic() []byte {
	if m != nil {
		return m.Public
	}
	return nil
}

func (m *AccountEvent) GetPrivate() []byte {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *AccountEvent) GetLastSeen() int64 {
	if m != nil {
		return m.LastSeen
	}
	return 0
}

func (m *AccountEvent) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *AccountEvent) GetAuthSchemes() []*AccountEvent_AuthScheme {
	if m != nil {
		return m.AuthSchemes
	}
	return nil
}

func (m *AccountEvent) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type AccountEvent_AuthScheme struct {
	Scheme string `protobuf:"bytes,1,opt,name=scheme" json:"scheme,omitempty"`
	Secret []byte `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *AccountEvent_AuthScheme) Reset()                    { *m = AccountEvent_AuthScheme{} }
func (m *AccountEvent_AuthScheme) String() string            { return proto.CompactTextString(m) }
func (*AccountEvent_AuthScheme) ProtoMessage()               {}
func (*AccountEvent_AuthScheme) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 0} }

func (m *AccountEvent_AuthScheme) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *AccountEvent_AuthScheme) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

type SubscriptionEvent struct {
	Action Crud      `protobuf:"varint,1,opt,name=action,enum=pbx.Crud" json:"action,omitempty"`
	SubId  string    `protobuf:"bytes,2,opt,name=sub_id,json=subId" json:"sub_id,omitempty"`
	Sub    *TopicSub `protobuf:"bytes,3,opt,name=sub" json:"sub,omitempty"`
}

func (m *SubscriptionEvent) Reset()                    { *m = SubscriptionEvent{} }
func (m *SubscriptionEvent) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionEvent) ProtoMessage()               {}
func (*SubscriptionEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *SubscriptionEvent) GetAction() Crud {
	if m != nil {
		return m.Action
	}
	return Crud_CREATE
}

func (m *SubscriptionEvent) GetSubId() string {
	if m != nil {
		return m.SubId
	}
	return ""
}

func (m *SubscriptionEvent) GetSub() *TopicSub {
	if m != nil {
		return m.Sub
	}
	return nil
}

type MessageEvent struct {
	Action Crud `protobuf:"varint,1,opt,name=action,enum=pbx.Crud" json:"action,omitempty"`
}

func (m *MessageEvent) Reset()                    { *m = MessageEvent{} }
func (m *MessageEvent) String() string            { return proto.CompactTextString(m) }
func (*MessageEvent) ProtoMessage()               {}
func (*MessageEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *MessageEvent) GetAction() Crud {
	if m != nil {
		return m.Action
	}
	return Crud_CREATE
}

func init() {
	proto.RegisterType((*Unused)(nil), "pbx.Unused")
	proto.RegisterType((*DefaultAcsMode)(nil), "pbx.DefaultAcsMode")
	proto.RegisterType((*AccessMode)(nil), "pbx.AccessMode")
	proto.RegisterType((*SetSub)(nil), "pbx.SetSub")
	proto.RegisterType((*SetDesc)(nil), "pbx.SetDesc")
	proto.RegisterType((*GetOpts)(nil), "pbx.GetOpts")
	proto.RegisterType((*BrowseOpts)(nil), "pbx.BrowseOpts")
	proto.RegisterType((*GetQuery)(nil), "pbx.GetQuery")
	proto.RegisterType((*SetQuery)(nil), "pbx.SetQuery")
	proto.RegisterType((*ClientHi)(nil), "pbx.ClientHi")
	proto.RegisterType((*ClientAcc)(nil), "pbx.ClientAcc")
	proto.RegisterType((*ClientLogin)(nil), "pbx.ClientLogin")
	proto.RegisterType((*ClientSub)(nil), "pbx.ClientSub")
	proto.RegisterType((*ClientLeave)(nil), "pbx.ClientLeave")
	proto.RegisterType((*ClientPub)(nil), "pbx.ClientPub")
	proto.RegisterType((*ClientGet)(nil), "pbx.ClientGet")
	proto.RegisterType((*ClientSet)(nil), "pbx.ClientSet")
	proto.RegisterType((*ClientDel)(nil), "pbx.ClientDel")
	proto.RegisterType((*ClientNote)(nil), "pbx.ClientNote")
	proto.RegisterType((*ClientMsg)(nil), "pbx.ClientMsg")
	proto.RegisterType((*TopicDesc)(nil), "pbx.TopicDesc")
	proto.RegisterType((*TopicSub)(nil), "pbx.TopicSub")
	proto.RegisterType((*ServerCtrl)(nil), "pbx.ServerCtrl")
	proto.RegisterType((*ServerData)(nil), "pbx.ServerData")
	proto.RegisterType((*ServerPres)(nil), "pbx.ServerPres")
	proto.RegisterType((*ServerMeta)(nil), "pbx.ServerMeta")
	proto.RegisterType((*ServerInfo)(nil), "pbx.ServerInfo")
	proto.RegisterType((*ServerMsg)(nil), "pbx.ServerMsg")
	proto.RegisterType((*ServerResp)(nil), "pbx.ServerResp")
	proto.RegisterType((*Session)(nil), "pbx.Session")
	proto.RegisterType((*ClientReq)(nil), "pbx.ClientReq")
	proto.RegisterType((*TopicEvent)(nil), "pbx.TopicEvent")
	proto.RegisterType((*AccountEvent)(nil), "pbx.AccountEvent")
	proto.RegisterType((*AccountEvent_AuthScheme)(nil), "pbx.AccountEvent.AuthScheme")
	proto.RegisterType((*SubscriptionEvent)(nil), "pbx.SubscriptionEvent")
	proto.RegisterType((*MessageEvent)(nil), "pbx.MessageEvent")
	proto.RegisterEnum("pbx.InfoNote", InfoNote_name, InfoNote_value)
	proto.RegisterEnum("pbx.Crud", Crud_name, Crud_value)
	proto.RegisterEnum("pbx.ClientDel_What", ClientDel_What_name, ClientDel_What_value)
	proto.RegisterEnum("pbx.ServerPres_What", ServerPres_What_name, ServerPres_What_value)
	proto.RegisterEnum("pbx.ServerResp_RespCode", ServerResp_RespCode_name, ServerResp_RespCode_value)
	proto.RegisterEnum("pbx.Session_AuthLevel", Session_AuthLevel_name, Session_AuthLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Node service

type NodeClient interface {
	// Client sends a stream of ClientMsg, server responds with a stream of ServerMsg
	MessageLoop(ctx context.Context, opts ...grpc.CallOption) (Node_MessageLoopClient, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) MessageLoop(ctx context.Context, opts ...grpc.CallOption) (Node_MessageLoopClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Node_serviceDesc.Streams[0], c.cc, "/pbx.Node/MessageLoop", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeMessageLoopClient{stream}
	return x, nil
}

type Node_MessageLoopClient interface {
	Send(*ClientMsg) error
	Recv() (*ServerMsg, error)
	grpc.ClientStream
}

type nodeMessageLoopClient struct {
	grpc.ClientStream
}

func (x *nodeMessageLoopClient) Send(m *ClientMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeMessageLoopClient) Recv() (*ServerMsg, error) {
	m := new(ServerMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Node service

type NodeServer interface {
	// Client sends a stream of ClientMsg, server responds with a stream of ServerMsg
	MessageLoop(Node_MessageLoopServer) error
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_MessageLoop_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).MessageLoop(&nodeMessageLoopServer{stream})
}

type Node_MessageLoopServer interface {
	Send(*ServerMsg) error
	Recv() (*ClientMsg, error)
	grpc.ServerStream
}

type nodeMessageLoopServer struct {
	grpc.ServerStream
}

func (x *nodeMessageLoopServer) Send(m *ServerMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeMessageLoopServer) Recv() (*ClientMsg, error) {
	m := new(ClientMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbx.Node",
	HandlerType: (*NodeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MessageLoop",
			Handler:       _Node_MessageLoop_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "model.proto",
}

// Client API for Plugin service

type PluginClient interface {
	// This plugin method is called by Tinode server for every message received from the clients. The
	// method returns a ServerCtrl message. ServerCtrl.code is *not* 0 indicates that no further
	// processing is needed. The Tinode server will generate a {ctrl} message from the returned ServerCtrl
	// and forward it to the client session.
	// If ServerCtrl.code is 0, the server should continue with default processing of the client message.
	FireHose(ctx context.Context, in *ClientReq, opts ...grpc.CallOption) (*ServerResp, error)
	// Account created, updated or deleted
	Account(ctx context.Context, in *AccountEvent, opts ...grpc.CallOption) (*Unused, error)
	// Topic created, updated [or deleted -- not supported yet]
	Topic(ctx context.Context, in *TopicEvent, opts ...grpc.CallOption) (*Unused, error)
	// Subscription created, updated or deleted
	Subscription(ctx context.Context, in *SubscriptionEvent, opts ...grpc.CallOption) (*Unused, error)
	// Message published or deleted
	Message(ctx context.Context, in *MessageEvent, opts ...grpc.CallOption) (*Unused, error)
}

type pluginClient struct {
	cc *grpc.ClientConn
}

func NewPluginClient(cc *grpc.ClientConn) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) FireHose(ctx context.Context, in *ClientReq, opts ...grpc.CallOption) (*ServerResp, error) {
	out := new(ServerResp)
	err := grpc.Invoke(ctx, "/pbx.Plugin/FireHose", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Account(ctx context.Context, in *AccountEvent, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/pbx.Plugin/Account", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Topic(ctx context.Context, in *TopicEvent, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/pbx.Plugin/Topic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Subscription(ctx context.Context, in *SubscriptionEvent, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/pbx.Plugin/Subscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Message(ctx context.Context, in *MessageEvent, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/pbx.Plugin/Message", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Plugin service

type PluginServer interface {
	// This plugin method is called by Tinode server for every message received from the clients. The
	// method returns a ServerCtrl message. ServerCtrl.code is *not* 0 indicates that no further
	// processing is needed. The Tinode server will generate a {ctrl} message from the returned ServerCtrl
	// and forward it to the client session.
	// If ServerCtrl.code is 0, the server should continue with default processing of the client message.
	FireHose(context.Context, *ClientReq) (*ServerResp, error)
	// Account created, updated or deleted
	Account(context.Context, *AccountEvent) (*Unused, error)
	// Topic created, updated [or deleted -- not supported yet]
	Topic(context.Context, *TopicEvent) (*Unused, error)
	// Subscription created, updated or deleted
	Subscription(context.Context, *SubscriptionEvent) (*Unused, error)
	// Message published or deleted
	Message(context.Context, *MessageEvent) (*Unused, error)
}

func RegisterPluginServer(s *grpc.Server, srv PluginServer) {
	s.RegisterService(&_Plugin_serviceDesc, srv)
}

func _Plugin_FireHose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).FireHose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbx.Plugin/FireHose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).FireHose(ctx, req.(*ClientReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Account_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Account(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbx.Plugin/Account",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Account(ctx, req.(*AccountEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Topic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Topic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbx.Plugin/Topic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Topic(ctx, req.(*TopicEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Subscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Subscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbx.Plugin/Subscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Subscription(ctx, req.(*SubscriptionEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Message_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Message(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbx.Plugin/Message",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Message(ctx, req.(*MessageEvent))
	}
	return interceptor(ctx, in, info, handler)
}

var _Plugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbx.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FireHose",
			Handler:    _Plugin_FireHose_Handler,
		},
		{
			MethodName: "Account",
			Handler:    _Plugin_Account_Handler,
		},
		{
			MethodName: "Topic",
			Handler:    _Plugin_Topic_Handler,
		},
		{
			MethodName: "Subscription",
			Handler:    _Plugin_Subscription_Handler,
		},
		{
			MethodName: "Message",
			Handler:    _Plugin_Message_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model.proto",
}

func init() { proto.RegisterFile("model.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x38, 0xcd, 0x72, 0xdb, 0xc8,
	0xd1, 0x22, 0x41, 0x82, 0x40, 0x93, 0x96, 0xe0, 0xf9, 0xf4, 0x79, 0xb9, 0x72, 0xbc, 0xb6, 0x61,
	0x67, 0xd7, 0x25, 0x67, 0x95, 0x8d, 0x1c, 0x27, 0x9b, 0x64, 0xab, 0x52, 0xb4, 0x48, 0x4b, 0x2a,
	0x4b, 0x22, 0x03, 0x4a, 0x9b, 0x4b, 0xaa, 0x58, 0x20, 0x30, 0x22, 0x51, 0x4b, 0x01, 0x14, 0x66,
	0x40, 0xdb, 0x55, 0xa9, 0x54, 0xe5, 0x90, 0xc3, 0xe6, 0x98, 0x17, 0xc8, 0x2d, 0xd7, 0xe4, 0x90,
	0xa7, 0x48, 0x9e, 0x20, 0xa7, 0x3c, 0x43, 0xee, 0x39, 0xa4, 0x7a, 0x66, 0xf0, 0x2b, 0xcb, 0xab,
	0xfc, 0x5c, 0x50, 0x33, 0xdd, 0x3d, 0x3d, 0xfd, 0xdf, 0x8d, 0x81, 0xf6, 0x45, 0xe4, 0xd3, 0xc5,
	0xce, 0x32, 0x8e, 0x78, 0x44, 0xb4, 0xe5, 0xf4, 0x8d, 0x6d, 0x80, 0x7e, 0x16, 0x26, 0x8c, 0xfa,
	0xf6, 0xe7, 0xb0, 0xde, 0xa7, 0xe7, 0x6e, 0xb2, 0xe0, 0x3d, 0x8f, 0x1d, 0x47, 0x3e, 0x25, 0x04,
	0x1a, 0x6e, 0xc2, 0xe7, 0xdd, 0xda, 0x83, 0xda, 0x13, 0xd3, 0x11, 0x6b, 0x01, 0x0b, 0xa3, 0xb0,
	0x5b, 0x57, 0xb0, 0x30, 0x0a, 0xed, 0x1f, 0x00, 0xf4, 0x3c, 0x8f, 0xb2, 0xec, 0xd4, 0x6b, 0x37,
	0xe4, 0xe9, 0x29, 0x5c, 0x93, 0x4d, 0x68, 0xce, 0x82, 0x15, 0x4d, 0x8f, 0xc9, 0x8d, 0xfd, 0x1c,
	0xf4, 0x31, 0xe5, 0xe3, 0x64, 0x4a, 0x3e, 0x80, 0x56, 0xc2, 0x68, 0x3c, 0x09, 0x7c, 0x75, 0x4c,
	0xc7, 0xed, 0xa1, 0x8f, 0xcc, 0x50, 0xe4, 0xf4, 0x3a, 0x5c, 0xdb, 0x97, 0xd0, 0x1a, 0x53, 0xde,
	0xa7, 0xcc, 0x23, 0xdf, 0x87, 0xb6, 0x2f, 0x65, 0x9e, 0xb8, 0x1e, 0x13, 0x67, 0xdb, 0xbb, 0xff,
	0xb7, 0xb3, 0x9c, 0xbe, 0xd9, 0x29, 0xeb, 0xe2, 0x80, 0x9f, 0xed, 0xc9, 0x1d, 0xd0, 0x97, 0xc9,
	0x74, 0x11, 0x78, 0x82, 0x6d, 0xc7, 0x51, 0x3b, 0xd2, 0x85, 0xd6, 0x32, 0x0e, 0x56, 0x2e, 0xa7,
	0x5d, 0x4d, 0x20, 0xd2, 0xad, 0xfd, 0x0a, 0x5a, 0xfb, 0x94, 0x0f, 0x97, 0x9c, 0x91, 0x6d, 0xb8,
	0x1d, 0x9c, 0x4f, 0x2e, 0x22, 0x3f, 0x38, 0x0f, 0xa8, 0x3f, 0x61, 0x41, 0xe8, 0x51, 0x71, 0xb1,
	0xe6, 0x6c, 0x04, 0xe7, 0xc7, 0x0a, 0x3e, 0x46, 0x30, 0xaa, 0xbd, 0x08, 0x2e, 0x02, 0x2e, 0xee,
	0x69, 0x3a, 0x72, 0x63, 0xff, 0xae, 0x06, 0xf0, 0x22, 0x8e, 0x5e, 0x33, 0x2a, 0x18, 0x7e, 0x08,
	0x86, 0x60, 0x92, 0x2a, 0xdf, 0x74, 0x5a, 0x62, 0x7f, 0xe8, 0xe7, 0x28, 0xce, 0x04, 0x0b, 0x4d,
	0xa1, 0x4e, 0x19, 0xb9, 0x0b, 0xe6, 0x94, 0x9e, 0x47, 0xb1, 0x38, 0xa6, 0x89, 0x63, 0x86, 0x04,
	0x1c, 0xfa, 0x05, 0x24, 0x67, 0xdd, 0x86, 0x38, 0xa8, 0x90, 0xa7, 0x2c, 0x17, 0xaa, 0x59, 0x14,
	0xea, 0x37, 0x35, 0x30, 0xf6, 0x29, 0xff, 0x59, 0x42, 0xe3, 0xb7, 0xc2, 0x85, 0x73, 0x37, 0x77,
	0xe1, 0xdc, 0xe5, 0xe4, 0x01, 0x34, 0x7c, 0xca, 0xa4, 0xc9, 0xda, 0xbb, 0x1d, 0x61, 0x63, 0x65,
	0x13, 0x47, 0x60, 0xc8, 0x47, 0xa0, 0xb1, 0x64, 0x2a, 0x84, 0xa9, 0x12, 0x20, 0x82, 0x3c, 0x82,
	0x86, 0xef, 0x72, 0x57, 0x08, 0xd4, 0xde, 0xdd, 0x10, 0x04, 0xb9, 0x1d, 0x1c, 0x81, 0xb4, 0x5f,
	0x81, 0x31, 0x4e, 0xc5, 0x48, 0xaf, 0xac, 0x15, 0x38, 0x2a, 0xcf, 0xab, 0x2b, 0xef, 0xc9, 0x2b,
	0xa5, 0x4c, 0xed, 0x94, 0x60, 0x9c, 0x4c, 0xc5, 0x8d, 0xf6, 0x2f, 0xc1, 0xd8, 0x5b, 0x04, 0x34,
	0xe4, 0x07, 0x01, 0x59, 0x87, 0x7a, 0x16, 0x5d, 0xf5, 0xc0, 0x27, 0xf7, 0x00, 0x44, 0xc8, 0xb9,
	0x33, 0x1a, 0x72, 0x15, 0x5f, 0x26, 0x42, 0x7a, 0x08, 0x20, 0x16, 0x68, 0x2b, 0x1a, 0x2b, 0xcb,
	0xe2, 0x12, 0x8d, 0xea, 0xd3, 0x55, 0x20, 0x1d, 0xd5, 0x10, 0xf4, 0x86, 0x04, 0xc8, 0x38, 0x5d,
	0xb8, 0xe1, 0x4c, 0xd8, 0xd4, 0x74, 0xc4, 0xda, 0xfe, 0x53, 0x0d, 0x4c, 0x79, 0x7d, 0xcf, 0xf3,
	0xae, 0xdc, 0x5f, 0x08, 0xf9, 0x7a, 0x29, 0xe4, 0xef, 0x80, 0xce, 0xbc, 0x39, 0xbd, 0x90, 0x41,
	0x68, 0x3a, 0x6a, 0x27, 0xe0, 0xd4, 0x8b, 0x29, 0x17, 0x97, 0x77, 0x1c, 0xb5, 0x13, 0xfe, 0x8c,
	0x66, 0x41, 0x28, 0xee, 0x36, 0x1c, 0xb9, 0x41, 0x81, 0xb8, 0x3b, 0x63, 0x5d, 0xfd, 0x81, 0x86,
	0x02, 0xe1, 0x3a, 0xb3, 0x67, 0xeb, 0x3a, 0x7b, 0xda, 0xc7, 0xd0, 0x96, 0x12, 0x1f, 0x09, 0x26,
	0x55, 0x99, 0x73, 0xd1, 0xea, 0xd7, 0x88, 0xa6, 0x15, 0x45, 0xb3, 0xbf, 0xce, 0x2c, 0x80, 0x49,
	0x5e, 0xe5, 0xb6, 0x09, 0x4d, 0x1e, 0x2d, 0x55, 0x16, 0x9a, 0x8e, 0xdc, 0x90, 0x6d, 0x30, 0x19,
	0xe5, 0x93, 0x4b, 0x8c, 0x00, 0x15, 0x4b, 0xb7, 0x52, 0x49, 0x45, 0x58, 0x38, 0x06, 0x4b, 0x03,
	0x64, 0x1b, 0xcc, 0x59, 0x46, 0xdb, 0x28, 0xd0, 0xee, 0x67, 0xb4, 0x33, 0xb5, 0xb2, 0x0f, 0x33,
	0xd5, 0xa8, 0xbb, 0xa2, 0x37, 0x14, 0x66, 0x13, 0x9a, 0x49, 0x98, 0x06, 0xb5, 0xe1, 0xc8, 0x8d,
	0xfd, 0xd7, 0x4c, 0xad, 0xd1, 0x8d, 0xd5, 0xfa, 0x00, 0x5a, 0x61, 0x34, 0xa1, 0xde, 0x3c, 0x52,
	0xbc, 0xf4, 0x30, 0x1a, 0x78, 0xf3, 0x88, 0x7c, 0x07, 0x1a, 0x73, 0xea, 0x62, 0x44, 0x69, 0x4f,
	0xda, 0xbb, 0x5d, 0x21, 0x7e, 0xc6, 0x7c, 0xe7, 0x80, 0xba, 0xfe, 0x20, 0xe4, 0xf1, 0x5b, 0x47,
	0x50, 0x61, 0x89, 0xf2, 0xa2, 0x90, 0x63, 0xc8, 0x36, 0x65, 0x89, 0x52, 0xdb, 0xad, 0x1f, 0x82,
	0x99, 0x11, 0x63, 0xf4, 0x7e, 0x45, 0xdf, 0x2a, 0xa1, 0x70, 0x89, 0x52, 0xad, 0xdc, 0x45, 0x92,
	0x7a, 0x4e, 0x6e, 0x7e, 0x5c, 0xff, 0xbc, 0x66, 0x7f, 0x99, 0x2a, 0xb3, 0x4f, 0xf9, 0x0d, 0x95,
	0x79, 0x04, 0xcd, 0xab, 0xfe, 0xc9, 0x6c, 0x2e, 0x71, 0x39, 0xdf, 0xf1, 0x7f, 0xc7, 0x77, 0x5c,
	0xe1, 0xfb, 0xf7, 0xcc, 0xfa, 0x7d, 0xba, 0xb8, 0x21, 0xe3, 0x4f, 0x54, 0x41, 0x43, 0xbe, 0xeb,
	0xaa, 0x41, 0x64, 0x3c, 0x76, 0x7e, 0x3e, 0x77, 0xb9, 0xaa, 0x72, 0x77, 0x40, 0x97, 0x85, 0x52,
	0x84, 0x53, 0xd3, 0x51, 0x3b, 0x51, 0x89, 0xe9, 0xe5, 0x64, 0x11, 0x30, 0x34, 0xbc, 0x26, 0x8a,
	0x34, 0xbd, 0x3c, 0x0a, 0x18, 0x2f, 0x26, 0xb2, 0x5e, 0xed, 0x5d, 0x73, 0x37, 0xf6, 0x45, 0xba,
	0x19, 0x8e, 0x58, 0xdb, 0x8f, 0xa0, 0x81, 0xb7, 0x91, 0x16, 0x68, 0xc7, 0xe3, 0x7d, 0x6b, 0x8d,
	0x98, 0xd0, 0x3c, 0x1d, 0x8e, 0x0e, 0xf7, 0xac, 0x1a, 0xc2, 0xc6, 0x67, 0x2f, 0xac, 0xba, 0xfd,
	0x0b, 0x00, 0x29, 0xdc, 0x49, 0xc4, 0x69, 0xae, 0x51, 0xad, 0xa8, 0xd1, 0x43, 0xa5, 0x51, 0x5d,
	0x68, 0x24, 0x2d, 0x75, 0x18, 0x9e, 0x47, 0x78, 0x44, 0xe9, 0xf2, 0xff, 0x98, 0x95, 0x97, 0x79,
	0x7f, 0x68, 0x32, 0x7a, 0x79, 0xe8, 0xdb, 0xbf, 0xd5, 0x52, 0xfb, 0x1d, 0xb3, 0x19, 0xb9, 0x0f,
	0xf5, 0x79, 0xa0, 0x2a, 0xec, 0xad, 0x82, 0x5d, 0x0e, 0x82, 0x83, 0x35, 0xa7, 0x3e, 0x0f, 0x88,
	0x0d, 0x9a, 0xeb, 0xa5, 0x65, 0x7f, 0xbd, 0x40, 0xd1, 0xf3, 0xbc, 0x83, 0x35, 0x07, 0x91, 0xe4,
	0x49, 0x5a, 0x82, 0xa4, 0xdf, 0xac, 0x02, 0x95, 0x28, 0x24, 0x07, 0x6b, 0x69, 0x59, 0xb2, 0x65,
	0xc1, 0x6e, 0x5c, 0xe1, 0x36, 0x4e, 0xa6, 0xc8, 0x0d, 0xfb, 0x04, 0x72, 0xc3, 0x1c, 0x15, 0x11,
	0x5e, 0xe1, 0x86, 0x70, 0xc1, 0x4d, 0x24, 0xb1, 0x0d, 0xda, 0x32, 0x99, 0x0a, 0xb3, 0x97, 0xb9,
	0x8d, 0x24, 0xb7, 0x65, 0x32, 0x45, 0x9a, 0x19, 0xe5, 0xaa, 0xe6, 0x15, 0x69, 0xf6, 0x29, 0x47,
	0x9a, 0x19, 0xe5, 0x42, 0x2a, 0xca, 0xbb, 0xc6, 0x55, 0xa9, 0x24, 0x0d, 0x93, 0x34, 0x3e, 0x5d,
	0x74, 0xcd, 0x2b, 0x34, 0x7d, 0xba, 0x40, 0x1a, 0x9f, 0x2e, 0xc8, 0xb7, 0xa1, 0x11, 0x46, 0x9c,
	0x76, 0xa1, 0xd0, 0xe1, 0x72, 0x4f, 0x1e, 0xac, 0x39, 0x02, 0xfd, 0xc2, 0x84, 0xd6, 0x31, 0x65,
	0xcc, 0x9d, 0x51, 0xfb, 0x8f, 0x75, 0x30, 0x4f, 0xd1, 0xa1, 0x7d, 0xd9, 0xce, 0xc0, 0x8b, 0xa9,
	0xcb, 0xa9, 0x3f, 0x51, 0xdd, 0x57, 0x73, 0x4c, 0x05, 0xe9, 0x71, 0xd1, 0xb2, 0x96, 0x7e, 0x8a,
	0x96, 0x03, 0x81, 0xa9, 0x20, 0x3d, 0x4e, 0x9e, 0x82, 0x8e, 0x43, 0x8e, 0xc7, 0x94, 0x79, 0xdf,
	0x39, 0x07, 0x29, 0x12, 0xf2, 0x10, 0xdd, 0xca, 0x94, 0x89, 0xa5, 0xa4, 0xf9, 0x0c, 0x87, 0x5e,
	0x65, 0x85, 0xf8, 0xd1, 0x0b, 0xf1, 0x83, 0xf1, 0x1e, 0x53, 0xd7, 0x47, 0x78, 0x4b, 0xe6, 0x08,
	0x6e, 0x53, 0x84, 0xb7, 0x42, 0x84, 0x91, 0x22, 0xbc, 0x95, 0x1c, 0x63, 0xbc, 0x05, 0x75, 0x45,
	0x8a, 0x98, 0x72, 0xc2, 0x11, 0x7b, 0xd9, 0xec, 0xd4, 0x28, 0x06, 0xd7, 0x8d, 0x62, 0xed, 0xf2,
	0x28, 0xf6, 0x7b, 0x0d, 0x0c, 0x61, 0x31, 0x6c, 0x29, 0x65, 0x8b, 0xd4, 0xaa, 0x16, 0xb9, 0x07,
	0xe0, 0xd3, 0x05, 0x2d, 0x1b, 0x4c, 0x41, 0x7a, 0x22, 0xd9, 0xa3, 0x70, 0x11, 0x84, 0x34, 0x2d,
	0xc9, 0x72, 0x97, 0xda, 0xa6, 0xf1, 0x1e, 0xdb, 0x14, 0x8c, 0xd0, 0xbc, 0xce, 0x08, 0x7a, 0xc9,
	0x08, 0xb9, 0xa6, 0xad, 0xeb, 0x34, 0x35, 0x4a, 0x9a, 0x16, 0x0b, 0x8b, 0x59, 0x2a, 0x2c, 0x59,
	0x45, 0x80, 0x62, 0x45, 0xc8, 0xdd, 0xd5, 0x2e, 0xba, 0xab, 0x68, 0xfc, 0x4e, 0xd9, 0xf8, 0x8f,
	0x61, 0x7d, 0xe1, 0x32, 0x3e, 0x61, 0x94, 0x86, 0x13, 0x1e, 0x5c, 0xd0, 0xee, 0x2d, 0x61, 0xa2,
	0x0e, 0x42, 0xc7, 0x94, 0x86, 0xa7, 0xc1, 0x05, 0x25, 0xdf, 0x85, 0xcd, 0x9c, 0xaa, 0x30, 0x32,
	0xad, 0x8b, 0xcb, 0x6f, 0xa7, 0xb4, 0x67, 0xe9, 0xe8, 0x64, 0xff, 0xb9, 0x06, 0x30, 0xa6, 0xf1,
	0x8a, 0xc6, 0x7b, 0x3c, 0xbe, 0x5a, 0xa1, 0x09, 0x34, 0xbc, 0x74, 0xa4, 0x6f, 0x3a, 0x62, 0x2d,
	0xa6, 0x15, 0xfa, 0x86, 0xab, 0x89, 0x47, 0xac, 0xc9, 0x33, 0xd0, 0x97, 0x6e, 0xec, 0x5e, 0x30,
	0xd5, 0x1a, 0xef, 0xaa, 0x6e, 0x90, 0x32, 0xde, 0x19, 0x09, 0xac, 0xec, 0x8e, 0x8a, 0x74, 0xeb,
	0x47, 0xd0, 0x2e, 0x80, 0xbf, 0xa9, 0x0f, 0x76, 0x8a, 0x7d, 0xf0, 0x9f, 0x99, 0xd8, 0x7d, 0x97,
	0xbb, 0xd7, 0x94, 0xdd, 0x07, 0xd0, 0x39, 0x8f, 0xa3, 0x8b, 0x49, 0x79, 0x74, 0x03, 0x84, 0x9d,
	0x49, 0xe7, 0x94, 0x63, 0x4e, 0xab, 0xc6, 0x5c, 0xee, 0xa5, 0x46, 0xd1, 0x4b, 0x9f, 0xaa, 0x29,
	0xa0, 0x29, 0x54, 0xfd, 0xb0, 0xa0, 0x2a, 0x0a, 0xf3, 0xbe, 0x31, 0x40, 0xff, 0x1f, 0x8d, 0x01,
	0x5f, 0x6b, 0xa9, 0xfa, 0xa3, 0x98, 0xb2, 0x6b, 0xd4, 0xb7, 0x40, 0x63, 0x71, 0xda, 0x5b, 0x71,
	0x49, 0x9e, 0x94, 0x3a, 0xeb, 0x66, 0x41, 0x70, 0x64, 0x53, 0x6c, 0xad, 0xe5, 0x81, 0xbb, 0x51,
	0x1d, 0xb8, 0x73, 0xc3, 0x34, 0x2b, 0xe1, 0x9b, 0x35, 0x5e, 0xbd, 0xdc, 0x78, 0x1f, 0xc3, 0x3a,
	0x77, 0x63, 0x1c, 0x00, 0x53, 0x6f, 0xb4, 0x04, 0xd3, 0x8e, 0x84, 0x2a, 0x7f, 0xd8, 0x70, 0xcb,
	0xf5, 0x78, 0x14, 0x67, 0x44, 0x86, 0x20, 0x6a, 0x0b, 0xa0, 0xa2, 0x51, 0x09, 0x6f, 0x5e, 0x9f,
	0xf0, 0xf6, 0x57, 0xaa, 0x71, 0xeb, 0x50, 0x1f, 0x9e, 0x58, 0x6b, 0xd8, 0xac, 0x87, 0x2f, 0x5f,
	0x5a, 0x35, 0x04, 0x9c, 0xf5, 0x2c, 0x0d, 0x01, 0x67, 0xa3, 0xbe, 0xd5, 0x20, 0x06, 0x34, 0xf6,
	0x87, 0x27, 0x03, 0xab, 0x89, 0xa0, 0xde, 0xde, 0xd8, 0xd2, 0x11, 0x74, 0x3a, 0x70, 0x8e, 0xad,
	0x56, 0xda, 0xf7, 0x0d, 0x04, 0x39, 0x83, 0x5e, 0xdf, 0x32, 0xe5, 0x6a, 0xef, 0x4b, 0x0b, 0x10,
	0xd9, 0x1f, 0x1c, 0x59, 0x6d, 0xfb, 0x75, 0xea, 0x8a, 0x63, 0xca, 0xdd, 0x1b, 0x8e, 0x38, 0xb6,
	0x1a, 0xee, 0xb5, 0x42, 0x83, 0xca, 0x3a, 0x8b, 0xfa, 0x5d, 0xba, 0x9f, 0x76, 0x5f, 0x2d, 0xeb,
	0xf6, 0x69, 0x29, 0x95, 0x3f, 0x4c, 0xbf, 0x4a, 0x2f, 0xc6, 0x51, 0xe2, 0x3f, 0x4e, 0x81, 0x87,
	0xa5, 0x98, 0xf8, 0x86, 0xd9, 0xa4, 0x98, 0x06, 0xf6, 0xdf, 0x6a, 0x60, 0x2a, 0xcd, 0xd9, 0x0c,
	0xdb, 0xa9, 0xc7, 0xe3, 0x85, 0x9a, 0x4e, 0x36, 0x2a, 0xf9, 0x8f, 0xed, 0x14, 0xd1, 0x48, 0x26,
	0xfe, 0x2b, 0xeb, 0x57, 0xc8, 0x30, 0x77, 0x90, 0x0c, 0xd1, 0x48, 0xb6, 0x8c, 0x29, 0x53, 0x06,
	0xda, 0xa8, 0x44, 0x2a, 0x92, 0x21, 0x1a, 0xc9, 0x2e, 0x68, 0xe5, 0x2f, 0x35, 0x77, 0x06, 0x92,
	0x21, 0x1a, 0xc9, 0x82, 0xf0, 0x3c, 0x2a, 0x35, 0xd0, 0xdc, 0x74, 0x48, 0x86, 0xe8, 0x62, 0xab,
	0xff, 0x4b, 0x56, 0x5f, 0x1c, 0xca, 0x96, 0xe4, 0x33, 0xd0, 0x19, 0x77, 0x79, 0x22, 0x5f, 0x2d,
	0xd6, 0xd5, 0xe4, 0x9f, 0x13, 0xec, 0xe0, 0x67, 0x4f, 0xb4, 0x6c, 0x49, 0x47, 0x3e, 0x06, 0x9d,
	0xc5, 0xab, 0x0b, 0x36, 0x2b, 0x0d, 0x63, 0x99, 0xb9, 0x1c, 0x85, 0x25, 0x8f, 0xa1, 0xe9, 0x2d,
	0x90, 0x4c, 0xbb, 0x32, 0xab, 0x20, 0x99, 0x44, 0xda, 0x5f, 0x80, 0x91, 0xde, 0x40, 0x3a, 0x60,
	0xec, 0x0d, 0x4f, 0x4e, 0x0f, 0x4f, 0xce, 0x06, 0xd6, 0x1a, 0x06, 0x64, 0xdf, 0x19, 0x8e, 0xac,
	0x1a, 0x69, 0x43, 0xcb, 0x19, 0x8c, 0x47, 0xc3, 0x93, 0xbe, 0x55, 0x97, 0x9b, 0xd1, 0x51, 0x6f,
	0x6f, 0x60, 0x69, 0xf6, 0x1f, 0xea, 0xd0, 0x1a, 0x53, 0xc6, 0x82, 0x28, 0xc4, 0xc4, 0x66, 0x72,
	0x99, 0xbf, 0xdf, 0x98, 0x0a, 0x72, 0xf8, 0x9e, 0x1f, 0xdd, 0xe7, 0x00, 0x6e, 0xc2, 0xe7, 0x93,
	0x05, 0x5d, 0xd1, 0x85, 0x0a, 0x96, 0x3b, 0x4a, 0x27, 0x71, 0x78, 0xa7, 0x97, 0xf0, 0xf9, 0x11,
	0x62, 0x1d, 0xd3, 0x4d, 0x97, 0xe4, 0x3e, 0xb4, 0x63, 0x7a, 0x11, 0x71, 0x3a, 0x71, 0x7d, 0x3f,
	0x56, 0x85, 0x04, 0x24, 0xa8, 0xe7, 0xfb, 0x71, 0xa5, 0xd0, 0x34, 0xab, 0x85, 0xa6, 0xf4, 0x1f,
	0xaf, 0x57, 0xfe, 0xe3, 0xb7, 0xc0, 0xc0, 0x7f, 0xf7, 0xc4, 0x9d, 0x51, 0x55, 0x4d, 0xb2, 0xbd,
	0xfd, 0x0c, 0xcc, 0x4c, 0x20, 0x34, 0xd2, 0x09, 0x66, 0xb9, 0x30, 0x57, 0xef, 0x64, 0x78, 0x62,
	0x81, 0x58, 0x9d, 0x9d, 0x1e, 0x58, 0x9b, 0x22, 0xa7, 0x87, 0xc3, 0x53, 0xeb, 0x23, 0x7b, 0x98,
	0x0e, 0xdb, 0x0e, 0xbd, 0x24, 0x0f, 0x40, 0x43, 0xbf, 0xd4, 0xde, 0xe9, 0x17, 0x44, 0xe1, 0x2f,
	0x3a, 0x5a, 0xae, 0xf4, 0xca, 0xa2, 0xac, 0xe1, 0x08, 0x8c, 0x3d, 0x03, 0x10, 0x39, 0x3b, 0x58,
	0xa1, 0x32, 0x0f, 0x41, 0x77, 0x3d, 0x1e, 0x44, 0xa1, 0x8a, 0x22, 0x53, 0x32, 0x8d, 0x13, 0xdf,
	0x51, 0x08, 0xec, 0xad, 0xa1, 0x9b, 0xfd, 0xb2, 0x8b, 0xf5, 0x4d, 0x8a, 0x85, 0xfd, 0x6b, 0x0d,
	0x3a, 0x3d, 0xcf, 0x8b, 0x92, 0x90, 0xdf, 0xf8, 0xae, 0x6b, 0x7d, 0x5d, 0x79, 0xa8, 0xd3, 0xfe,
	0xdd, 0x87, 0xba, 0xc6, 0x75, 0x33, 0x53, 0xb3, 0x3c, 0x33, 0xdd, 0x05, 0x33, 0x1b, 0x56, 0x84,
	0x73, 0x35, 0x74, 0xa0, 0x9c, 0x50, 0x2a, 0x81, 0xd1, 0xaa, 0x06, 0xc6, 0x4f, 0xa1, 0x23, 0xe2,
	0x51, 0x3e, 0x6a, 0xb0, 0xae, 0x21, 0xca, 0xe4, 0xb7, 0xd2, 0x76, 0x90, 0x19, 0x42, 0x84, 0xe5,
	0x58, 0x10, 0x39, 0x6d, 0x37, 0x5b, 0xb3, 0xec, 0xcd, 0xc5, 0xcc, 0xdf, 0x5c, 0xb6, 0xbe, 0x00,
	0xc8, 0xc9, 0x0b, 0x0f, 0x28, 0xb5, 0x6b, 0x1e, 0x50, 0xea, 0xa5, 0x07, 0x94, 0x10, 0x6e, 0x8f,
	0x93, 0x29, 0xf3, 0xe2, 0x60, 0x89, 0xf6, 0xbd, 0xb1, 0x1f, 0xb0, 0xbc, 0x26, 0xd3, 0xdc, 0x0d,
	0x4d, 0x96, 0x4c, 0x0f, 0xfd, 0xb4, 0xfe, 0x17, 0xff, 0xae, 0xcb, 0xf5, 0xff, 0x7b, 0xd0, 0x51,
	0xe5, 0xea, 0xa6, 0x57, 0x6d, 0x7f, 0x0c, 0x46, 0x5a, 0xdb, 0xb3, 0xa6, 0xb6, 0x96, 0x35, 0x35,
	0xd1, 0x1f, 0x5f, 0x8d, 0xac, 0xfa, 0xf6, 0x36, 0x34, 0xf0, 0x1c, 0x01, 0xd0, 0xf7, 0x9c, 0x41,
	0xef, 0x14, 0x53, 0x07, 0x40, 0x3f, 0x1b, 0xf5, 0x71, 0x5d, 0xc3, 0x75, 0x7f, 0x70, 0x34, 0x38,
	0x1d, 0x58, 0xf5, 0xdd, 0x9f, 0x40, 0xe3, 0x04, 0xeb, 0xd2, 0x33, 0x68, 0x2b, 0x71, 0x8e, 0xa2,
	0x68, 0x49, 0x2a, 0x19, 0xb3, 0x55, 0x29, 0x80, 0xf6, 0xda, 0x93, 0xda, 0x67, 0xb5, 0xdd, 0x7f,
	0xd4, 0x40, 0x1f, 0x2d, 0x12, 0xfc, 0xdb, 0xfc, 0x14, 0x8c, 0x97, 0x41, 0x4c, 0x0f, 0x22, 0x46,
	0x4b, 0x87, 0x1d, 0x7a, 0xb9, 0xb5, 0x51, 0xa9, 0xb7, 0xf6, 0x1a, 0x79, 0x0a, 0x2d, 0xe5, 0x67,
	0x72, 0xfb, 0x8a, 0xd7, 0xb7, 0xe4, 0xf3, 0xa2, 0x7a, 0x2c, 0x5f, 0x23, 0x9f, 0x40, 0x53, 0xd8,
	0x8e, 0x6c, 0xe4, 0x76, 0x7c, 0x27, 0xe1, 0x73, 0xe8, 0x14, 0x7d, 0x48, 0x54, 0x89, 0xab, 0xba,
	0xb5, 0x7a, 0xec, 0x69, 0xd6, 0x39, 0x94, 0x30, 0x45, 0xc7, 0x54, 0x88, 0xa7, 0xba, 0x78, 0xd1,
	0x7f, 0xf6, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xd8, 0x0a, 0x1b, 0xe0, 0x17, 0x00, 0x00,
}
